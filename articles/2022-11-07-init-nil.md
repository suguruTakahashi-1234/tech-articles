---
title: "[Swift] イニシャライズで失敗する場合は nil を返すのではなく throw しよう"
emoji: "🕊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Swift"]
published: true
---

# 伝えたいこと

- イニシャライズで失敗する場合は `nil` を返すのではなく、エラーを `throw` しよう
  - メリット
    - `throw` した先で `nil` にもできるし、さらに `throw` することも可能である
    - エラーの内容を出し分けることや enum の連想値で情報を持たせることも可能
  - デメリット
    - 特になし

# (before) `nil` を返却する場合

```swift
struct NilHoge {
    var moge: Int
    var fuga: Int
    
    init?(moge: Int, fuga: Int) {
        guard moge > 0 else {
            return nil
        }
        guard fuga > 0 else {
            return nil
        }
        self.moge = moge
        self.fuga = fuga
    }
}
```

## イニシャライズに失敗した場合は nil をアンラップすることしかできない

```swift
func testFuncNilHoge(moge: Int, fuga: Int) -> NilHoge? {
    guard let nilHoge = NilHoge(moge: moge, fuga: fuga) else {
        print("Initialization failed")
        return nil
    }
    print(nilHoge)
    return nilHoge
}

testFuncNilHoge(moge: 1, fuga: -1) // Initialization failed
```

`nil` の意味が不透明であり、何によってイニシャライズが失敗したかの情報が `nil` だけでは表すことができません。
-> `moge` の値がよくなかったのか、`fuga` の値がよくなかったのかがわからない

# (after) エラーを `throw` する場合

```swift
enum HogeInitializeError: Error {
    case mogeError(Int)
    case fugaError(Int)
}

struct ThrowsHoge {
    var moge: Int
    var fuga: Int
    
    init(moge: Int, fuga: Int) throws {
        guard moge > 0 else {
            throw HogeInitializeError.mogeError(moge) // <-
        }
        guard fuga > 0 else {
            throw HogeInitializeError.mogeError(fuga) // <-
        }
        self.moge = moge
        self.fuga = fuga
    }
}
```

以下のパターンのように、`throw` されたエラーを好きなようにハンドリングすることができます。

## (パターン1) try? して guard let でアンラップする

```swift
func testFuncThrowsHoge1(moge: Int, fuga: Int) -> ThrowsHoge? {
    guard let throwsHoge = try? ThrowsHoge(moge: moge, fuga: fuga) else {
        print("Initialization failed")
        return nil
    }
    print(throwsHoge)
    return throwsHoge
}

testFuncThrowsHoge1(moge: 1, fuga: -1) // Initialization failed
```

## (パターン2) do-catch でエラーハンドリングする

```swift
func testFuncThrowsHoge2(moge: Int, fuga: Int) -> ThrowsHoge {
    do {
        let throwsHoge = try ThrowsHoge(moge: moge, fuga: fuga)
        print(throwsHoge)
        return throwsHoge
    } catch {
        fatalError("\(error)")
    }
}

testFuncThrowsHoge2(moge: 1, fuga: -1) // __lldb_expr_222/init thorow.playground:66: Fatal error: mogeError(-1)
```

## (パターン3) さらに throws する

```swift
func testFuncThrowsHoge3(moge: Int, fuga: Int) throws -> ThrowsHoge {
    let throwsHoge = try ThrowsHoge(moge: moge, fuga: fuga)
    print(throwsHoge)
    return throwsHoge
}

// 3-1. さらに throws することも可能
func testFunc() throws {
    try testFuncThrowsHoge3(moge: 1, fuga: -1)
}

// 3-2. do-catch でハンドリング可能
do {
    try testFuncThrowsHoge3(moge: 1, fuga: -1)
} catch {
    print("\(error)") // mogeError(-1)
}
```

以上になります。