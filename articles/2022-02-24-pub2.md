---
title: "[Swift] [Combine] ObservableObject がなくても @Published は使用できる件"
emoji: "🌾"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Swift"]
published: false
---

# 伝えたいこと

- **`ObservableObject` を適応した class でなくても `@Published` は使用できる**
  - `ObservableObject` は `@StateObject`、`@ObservedObject`、`@EnvironmentObject` のアノテーションをつけた変数を使いたいときに使用する **= `SwiftUI` での View の実装で使用する**
- **`ObservableObject` を適応した class でない `@Published` の使い道として、`private(set)` としたい Publisher を記述するときに簡単に書けるようになる**（以下、サンプルコード参照）


```swift:これが
class Hoge {
    private let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    var mogemogePub: AnyPublisher<Int, Never> {
        mogemoge.eraseToAnyPublisher()
    }
}
```

```swift:こう書ける
class Hoge {
    @Published private(set) var mogemoge: Int = 0
}
```

以上になります。

# タイトル回収

`@Published` と `ObservableObject` はセットで使うものだと誤解されがちですが、そうではありません。

## ObservableObject をつけた場合

`ObservableObject` をつけると `@StateObject`、`@ObservedObject`、`@EnvironmentObject` のアノテーションをつけた変数で使用可能になります。

```swift
import SwiftUI

// ObservableObject をつける
class Hoge: ObservableObject {
    @Published private(set) var mogmoge: Int = 0
}

// コンパイルエラーにはならない🌟
class Piyo {
    @StateObject var hogeStateObject = Hoge()
    @ObservedObject var hogeObservedObject = Hoge()
    @EnvironmentObject var hogeEnvironmentObject: Hoge
}
```

また`@StateObject`、`@ObservedObject`、`@EnvironmentObject` を使用には `import SwiftUI` が必要となります。

**つまり、`ObservableObject` は `SwiftUI` での View の実装で使うものになります。**
（間違っておりましたらご指摘のほどお願いいたします🙇‍♂️）


## ObservableObject を外した場合

`ObservableObject` を外すと `@StateObject`、`@ObservedObject`、`@EnvironmentObject` のアノテーションをつけた変数で使用できなくなります。

```swift
import SwiftUI

// ObservableObject を外す
class Hoge {
    @Published private(set) var mogmoge: Int = 0
}

// コンパイルエラーとなる😭
class Piyo {
    @StateObject var hogeStateObject = Hoge() // Generic struct 'StateObject' requires that 'Hoge' conform to 'ObservableObject'
    @ObservedObject var hogeObservedObject = Hoge() // Generic struct 'ObservedObject' requires that 'Hoge' conform to 'ObservableObject'
    @EnvironmentObject var hogeEnvironmentObject: Hoge // Generic struct 'EnvironmentObject' requires that 'Hoge' conform to 'ObservableObject'
}
```

# ObservableObject ではない @Published の使い道

`ObservableObject` でなくても `@Published` が使えることは分かったのですが、その使い道を検討します。

## 結論

```swift:CurrentValueSubjectで書いていたこれが
class Hoge {
    private let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    var mogemogePub: AnyPublisher<Int, Never> {
        mogemoge.eraseToAnyPublisher()
    }
}
```

```swift:@Publishedを使うとこう書けるようになる
class Hoge {
    @Published private(set) var mogemoge: Int = 0
}
```

以上になります。


# 解説

## あ

以下のような、`mogemoge` の変更を subscribe していくことを前提としたクラスを用意します。

```swift
class Hoge {
    // CurrentValueSubject を用意
    let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    // Setter を用意
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge.value = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge.value)")
    }
}
```

この場合、Setter からも CurrentValueSubject の `.value` の両方で、`mogemoge` の値の更新が可能になっています。

```swift
let hoge = Hoge()

// subscribe を実施
hoge.mogemoge
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

// Setter から値の更新が可能
hoge.setMogemoge(1)

// CurrentValueSubject のため mogemoge.value = xxx でも値の更新が可能
hoge.mogemoge.value = 2

// 現在の Hoge().mogemoge の値を出力する
hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// receive: 2
// mogemoge: 2
```

ここで `setMogemoge()` のインターフェースでのみ値の変更をさせたいとします。

つまり、`CurrentValueSubject` の `.value = xxx` でのアクセスを禁止するようにします。

まず、思いつくのが、`mogemoge` に `private` のアクセス修飾子をつけることです。

## 方法1: CurrentValueSubject に `private` アクセス修飾子をつける

```swift
class Hoge {
    // private のアクセス修飾子をつける❗️❗️
    private let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge.value = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge.value)")
    }
}
```

しかし、`hoge.mogemoge.value = xxx` での変更は制限できる代わりに、残念ながら subscribe もできなくなります😭

```swift
let hoge = Hoge()

// subscribe できなくなった😭（コンパイルエラー）
hoge.mogemoge // 'mogemoge' is inaccessible due to 'private' protection level
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

// hoge.mogemoge.value = xxx で変更できなくなった ← 狙い通り😎
hoge.mogemoge.value = 2 // 'mogemoge' is inaccessible due to 'private' protection level

hoge.printMogemoge()
```

次の手として、`private(set)` を検討します。

## 方法2: CurrentValueSubject に `private(set)` のアクセス修飾子をつける

`mogemoge` に `private(set)` のアクセス修飾子をつけます。

```swift
class Hoge {
    // CurrentValueSubject を private(set) な変数とする
    private(set) var mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge.value = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge.value)")
    }
}
```

これで、`mogemoge` の subscribe を許可して、`hoge.mogemoge.value = xxx` で更新できなくできると思ったら、以下のように、そうはなりませんでした😭

```swift
let hoge = Hoge()

// subscribe できる🌟
hoge.mogemoge
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

// private(set) でも `hoge.mogemoge.value = xxx` してもコンパイルにならない😭
hoge.mogemoge.value = 2

hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// mogemoge: 1
// mogemoge: 2
```

`hoge.mogemoge.value = xxx` で更新できてしまいました😭

実はこれは当たり前のことで、以下のサンプルコードのように、クラスの更新ができないだけで、そのクラスのもつ変数は更新することができます。

### private(set) var の挙動について

```swift
class Moge {
    var piyopiyo: Int = 0
}

class Hoge {
    private(set) var moge: Moge = .init()
}

let hoge = Hoge()

// これはコンパイルエラー
hoge.moge = Moge() // Cannot assign to property: 'moge' setter is inaccessible

// コンパイルエラーとはならない
hoge.moge.piyopiyo = 1
```

なので、CurrentValueSubject に `private(set)` のアクセス修飾子をつけも、`hoge.mogemoge.value = xxx` といった直接の更新を防ぐことができません。


## 方法3: 別口の AnyPublisher を公開する(その1)

先ほどの CurrentValueSubject の `mogemoge` に `private` のアクセス修飾子をつけることに加えて、`mogemoge` とは別口で AnyPublisher でラッピングした `mogemogePub` として公開させます。

方法は以下の 2 種類あるのですが、今回は『`init()` で設定する』を紹介します、

- **`init()` で設定する** ← コチラ
- Computed property で設定する

```swift
class Hoge {
    private let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    // subscribe 専用の mogemogePub を用意
    let mogemogePub: AnyPublisher<Int, Never>
    
    init() {
        // init() で設定
        mogemogePub = mogemoge.eraseToAnyPublisher()
    }
    
    // Setter を用意
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge.value = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge.value)")
    }
}
```

`mogemoge` でのアクセスを制限したまま、`mogemogePub` を subscribe させます。

```swift
let hoge = Hoge()

// mogemogePub なら subscribe できる🌟
hoge.mogemogePub
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

// 以下でアクセスできずコンパイルエラー ← 狙い通り😎
// hoge.mogemoge.value = 2 // 'mogemoge' is inaccessible due to 'private' protection level

hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// mogemoge: 1
```

`setMogemoge()` のインターフェースでのみ値の変更に制限できて、`CurrentValueSubject` の `.value = xxx` でのアクセスを禁止することに成功しました。

## 方法4: 別口の AnyPublisher を公開する(その2)

続いて『Computed property で設定する』の方も紹介します。

- `init()` で設定する
- **Computed property で設定する** ← コチラ

```swift
class Hoge {
    private let mogemoge: CurrentValueSubject<Int, Never> = .init(0)
    
    // init() で設定せずに Computed property にすることも可能（ただし var となる）
    var mogemogePub: AnyPublisher<Int, Never> {
        mogemoge.eraseToAnyPublisher()
    }
    
    // Setter を用意
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge.value = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge.value)")
    }
}
```

先ほどと同様に、`mogemoge` でのアクセスを制限したまま、`mogemogePub` を subscribe させます。

```swift
let hoge = Hoge()

// mogemogePub なら subscribe できる🌟
hoge.mogemogePub
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// mogemoge: 1
```

これで、CurrentValueSubject の `mogemoge` に `private` のアクセス修飾子をつけることに加えて、`mogemoge` とは別口で AnyPublisher でラッピングした `mogemogePub` として公開させます。


# `@Published` の場合

```swift
class Hoge {
    // @Published をつける🌟
    @Published var mogemoge: Int = 0
    
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge)")
    }
}
```

```swift
let hoge = Hoge()

// `$` で Publisher としてアクセス可能に🌟
hoge.$mogemoge
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

// @Published var mogemoge は外から代入可能🌟
hoge.mogemoge = 2

hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// receive: 2
// mogemoge: 2
```


```swift
class Hoge {
    // @Published private をつける🌟
    @Published private var mogemoge: Int = 0
    
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge)")
    }
}
```

```swift
let hoge = Hoge()

// subscribe できなくなった😭（コンパイルエラー）
hoge.$mogemoge // '$mogemoge' is inaccessible due to 'private' protection level
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

// mogemoge = xxx で変更できなくなった ← 狙い通り😎
hoge.mogemoge = 2 // 'mogemoge' is inaccessible due to 'private' protection level

hoge.printMogemoge()
```


```swift
class Hoge {
    // @Published private(set) をつける🌟
    @Published private(set) var mogemoge: Int = 0
    
    func setMogemoge(_ mogemoge: Int) {
        self.mogemoge = mogemoge
    }
    
    func printMogemoge() {
        print("mogemoge: \(mogemoge)")
    }
}
```

```swift
let hoge = Hoge()

// @Published private(set) なら subscribe できる🌟
hoge.$mogemoge
    .sink { print("receive: \($0)") }
    .store(in: &cancellables)

hoge.setMogemoge(1)

hoge.printMogemoge()

//（出力）
// receive: 0
// receive: 1
// mogemoge: 1
```

正直、このような単純な Setter であれば、`private(set)` とする必要はないです。

しかし、特定のインターフェースのみで値を更新してほしいときは、`@Published private(set) var` にして、`@Published` な変数を直接更新する方法を遮断させます。
