---
title: "[Swift] 辞書型あれこれ"
emoji: "🌾"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Swift"]
published: false
---

# 伝えたいこと

- 辞書型を維持したまま処理するなら -> 辞書型を維持する処理 -> `.mapValues()`
- 辞書型を維持しなくても良いなら -> その段階で辞書型を変更するとよさそう -> `.map(\.value)`
- `.first(where: 条件)` は辞書型のまま使える

# `.map()` で `key` だけや `value` だけの配列を生成することができる

```swift
let dict: [Int: String] = [1: "one", 2: "two" , 3: "three"]

print(dict.map(\.key)) // [1, 3, 2]
print(dict.map(\.value)) // ["one", "three", "two"]
```

※ ただし、順番は担保されないので注意が必要

# `.mapValues()` で辞書型を維持したまま `value` だけ変換処理をする

```swift
let dict: [Int: String] = [1: "one", 2: "two" , 3: "three"]

print(dict.mapValues { $0.count }) // [1: 3, 2: 3, 3: 5]
```

`.map(\.value)` や `.mapValues()` を使うことで通常の配列っぽく扱うことが可能ですが、以下のことを念頭に置くとよさそうです。

- 辞書型を維持したまま処理するなら -> 辞書型を維持する処理 -> `.mapValues()`
- 辞書型を維持しなくても良いなら -> その段階で辞書型を変更するとよさそう -> `.map(\.value)`

# `.first(where: 条件)` は辞書型のまま使える

```swift
let dict: [Int: String] = [1: "one", 2: "two" , 3: "three"]

// 以下はすべて同じ結果である
print(dict.first(where: { $0.value == "two" })!.value) // two
print(dict.first(where: { $0.key == 2 })!.value) // two

// もちろん先にvalueに変換してもよし
print(dict.map(\.value).first(where: { $0 == "two" })!) // two
```

大体、配列と同じような処理をすることが辞書型でも可能みたいです。

以上です。