---
title: "【Swift, Combine】didSetのoldValueに相当する値をCombineのストリームで扱う方法"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Swift", "Combine"]
published: true
---

# 結論

- 初期値を設定したくない場合 -> `zip()` と `dropFirst()` を使う
- 初期値を設定したい場合 ->  `scan()` を使う

一般化した Publisher の拡張も紹介しますが、混乱の元なので個人的には使わないほうがいい気がしました。

## サンプルコード

### 初期値を設定したくない場合

#### zip()とdropFirst()を使う

```swift
var cancellables = Set<AnyCancellable>()
let numPublisher: PassthroughSubject<Int, Never> = .init()

numPublisher
    .zip(numPublisher.dropFirst())
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 出力なし
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

#### 初期値を設定したくない場合の一般化

```swift
// 一般化
extension Publisher {
    func withPrevious() -> AnyPublisher<(previous: Output, current: Output), Failure> {
        zip(self.dropFirst())
        .map { previous, current -> (previous: Output, current: Output) in (previous, current) }
        .eraseToAnyPublisher()
    }
}

// 使い方
numPublisher
    .withPrevious()
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 出力なし
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

### 初期値を設定したい場合

#### scan()を使う

```swift
var cancellables = Set<AnyCancellable>()
let numPublisher: PassthroughSubject<Int, Never> = .init()

numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

### 初期値を設定したい場合の一般化

```swift
// 一般化
extension Publisher {
    func withPrevious(initialPreviousValue: Output) -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan((initialPreviousValue, initialPreviousValue)) { ($0.1, $1) }.eraseToAnyPublisher()
    }
}

// 使い方
numPublisher
    .withPrevious(initialPreviousValue: 0)
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

本編は以上になります。

# 以降、一般系の導出の過程までのメモ書きになります

## 動機

以下のような Publisher とそれを subscribe する処理を用意します。

```swift
var cancellables = Set<AnyCancellable>()
let numPublisher: PassthroughSubject<Int, Never> = .init()

numPublisher
    .sink { print("receiveValue: \($0)") }
    .store(in: &cancellables)

numPublisher.send(1) // receiveValue: 1
numPublisher.send(2) // receiveValue: 2
numPublisher.send(3) // receiveValue: 3
```
このときに `sink()` の `receiveValue` で didSet の oldValue に相当する値を用いて処理したくなったのが、本記事の動機になります。


```swift
numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .sink { print("previous: \($0), current: \($1)") }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

Outputの変数名を定義するとタプルのIndexでアクセスする

```swift
numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .sink { output in
        // Outputの変数名を定義するとタプルでのアクセスがわかりづらい
        print("previous: \(output.0), current: \(output.1)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

Outputの変数名を定義してタプルのアクセスをわかりやすくする


```swift
numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .map { previous, current -> (previous: Int, current: Int) in (previous, current) }
    .sink { output in
        // map()でタプルの変数名を定義することでタプルでのアクセスがわかりやすくなる
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

もちろん、map()しなくてもタプルの変数名を定義するだけで良いと思います。

```swift
numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .sink { previous, current in // タプルの変数名を定義してもよい
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```
ただし、次に Publisher を拡張して、一般化する際に変数名の定義されていないタプルを返すと、定義をいちいち確認しなけれならないので、一般化する際はタプルの変数を定義してあげたほうが親切だと思います。

```swift
extension Publisher {
    func withPrevious(initialPreviousValue: Output) -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan((initialPreviousValue, initialPreviousValue)) { ($0.1, $1) }.eraseToAnyPublisher()
    }
}

numPublisher
    .withPrevious(initialPreviousValue: 0) // Publisherを拡張した関数により処理を省略
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```


```swift
numPublisher
    .withPrevious(0)
    .dropFirst() // dropFirst() で初期値を無視する
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // ← dropFirst() によって出力されない
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

ただし、この方法だと使用しない初期値（今回の場合は `0`）を定義しなければならない。

そこで、今の拡張で、初回を無視する一般化は Output の初期化の際に「Type 'Self.Output' has no member 'init'」のコンパイルエラーとなってしまいます。

```swift
extension Publisher {
    //  以下はコンパイルエラーとなってしまう
    func withPrevious() -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan((Output(), Output())) { ($0.1, $1) } // compile error: Type 'Self.Output' has no member 'init'
        .dropFirst()
        .eraseToAnyPublisher()
    }
}
```



```swift
numPublisher
    .scan(Optional<(Int?, Int)>.none) { ($0?.1, $1) }
    .compactMap { $0 }
    .compactMap { previous, current -> (previous: Int, current: Int)? in
        guard let previous = previous else { return nil }
        return (previous, current)
    }
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // ← compactMap()によって出力されない
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```



```swift
extension Publisher {
    func withPrevious() -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan(Optional<(Output?, Output)>.none) { ($0?.1, $1) }
        .compactMap { $0 }
        .compactMap { previous, current in
            guard let previous = previous else { return nil }
            return (previous, current)
        }
        .eraseToAnyPublisher()
    }
}

numPublisher
    .withPrevious() // Publisherを拡張した関数により処理を省略
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

scan()を使わずにdropFirst()したPublisherをzip()するだけ問題なさそう

```swift
numPublisher
    .zip(numPublisher.dropFirst())
    .map { previous, current -> (previous: Int, current: Int) in (previous, current) }
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)
```


```swift
extension Publisher {
    func withPrevious() -> AnyPublisher<(previous: Output, current: Output), Failure> {
        zip(self.dropFirst())
        .map { previous, current -> (previous: Output, current: Output) in (previous, current) }
        .eraseToAnyPublisher()
    }
}

numPublisher
    .withPrevious() // Publisherを拡張した関数により処理を省略
    .sink { output in
        print("previous: \(output.previous), current: \(output.current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 出力なし
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```


```swift
var cancellables = Set<AnyCancellable>()
let numPublisher: PassthroughSubject<Int, Never> = .init()
```

```swift
numPublisher
    .scan((0, 0)) { ($0.1, $1) }
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

```swift
numPublisher
    .zip(numPublisher.dropFirst())
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 出力なし
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

```swift
extension Publisher {
    func withPrevious(initialPreviousValue: Output) -> AnyPublisher<(previous: Output, current: Output), Failure> {
        scan((initialPreviousValue, initialPreviousValue)) { ($0.1, $1) }.eraseToAnyPublisher()
    }
    
    func withPrevious() -> AnyPublisher<(previous: Output, current: Output), Failure> {
        zip(self.dropFirst())
        .map { previous, current -> (previous: Output, current: Output) in (previous, current) }
        .eraseToAnyPublisher()
    }
}
```

```swift
numPublisher
    .withPrevious(initialPreviousValue: 0)
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // previous: 0, current: 1
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```

```swift
numPublisher
    .withPrevious()
    .sink { previous, current in
        print("previous: \(previous), current: \(current)")
    }
    .store(in: &cancellables)

numPublisher.send(1) // 出力なし
numPublisher.send(2) // previous: 1, current: 2
numPublisher.send(3) // previous: 2, current: 3
```