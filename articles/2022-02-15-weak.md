---
title: "【Swift】delegate の変数の weak はなぜいるのか？"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Swift", "Combine"]
published: false
---


先に結論

delegate に対応した self を設定して、弱参照させるパターンは以下の2通りがある。

- delegate を代入する際は `weak var` で宣言した変数を使う
  - メリット：シンプルである
  - デメリット：delegate 変数の外部からの変更や、delegete 代入忘れの恐れがある
- `lazy var` で delegate に適応した self を init で渡す際は `unowned let` で宣言した変数を使った方が
  - メリット：`weak var` を使う場合にあったようなデメリットがなくなる
  - デメリット：`lazy var` を使う影響で、そちらの変数が変更される恐れや、init されるタイミングによって思わぬバグが発生する

```swift
protocol HogeDelegate: AnyObject {
    func hogehoge()
}

class MogeClass {
    var delegate: HogeDelegate?
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate?.hogehoge()
    }
}

class FugaClass {
    let mogeClass: MogeClass
    
    init() {
        mogeClass = MogeClass()
        mogeClass.delegate = self
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func fugafuga() {
        mogeClass.mogemoge()
    }
}

extension FugaClass: HogeDelegate {
    func hogehoge() {
        print("called hogehoge() on FugaClass")
    }
}
```

当たり前の挙動の確認

fugaClass の fugafuga() の実行

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()

// (出力)
// called hogehoge() on FugaClass
```

fugaClass init して deinit する

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass = nil

// (出力)
// なし
```

あれ？
fugaClass が解放されない、、、

というか mogeClass も解放する術も失った、、、

```swift
class MogeClass {
    weak var delegate: HogeDelegate? // ← weak をつける
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate?.hogehoge()
    }
}
```

fugaClass init して deinit する

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass = nil

// （出力）
// deinit: FugaClass
// deinit: MogeClass
```

解放された！！


もちろん、fugaClass の fugafuga() の実行して、それから fugaClass に nil を代入しても解放される

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()
fugaClass = nil

// （出力）
// called hogehoge() on FugaClass
// deinit: FugaClass
// deinit: MogeClass
```

ただ、これだと、どうしても var で宣言するので、外から変更されたり、delegate を代入し忘れる可能性があります。

変更案：
MogeClass の init で delegate をもらうようにして、FugaClass で lazy var で self を渡す

```swift
protocol HogeDelegate: AnyObject {
    func hogehoge()
}

class MogeClass {
    let delegate: HogeDelegate // let に修正
    
    init(delegate: HogeDelegate) {
        self.delegate = delegate // init でもらうようにする
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate.hogehoge()
    }
}

class FugaClass {
    lazy var mogeClass = MogeClass(delegate: self) // lazy var で self を渡すようにする
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func fugafuga() {
        mogeClass.mogemoge()
    }
}

extension FugaClass: HogeDelegate {
    func hogehoge() {
        print("called hogehoge() on FugaClass")
    }
}
```

fugaClass の fugafuga() の実行

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()

// （出力）
// called hogehoge() on FugaClass
```

うん。問題ない。


fugaClass init して deinit する

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass = nil

// （出力）
// deinit: FugaClass
```

MogeClass が解放されていないように見えるが、そもそも生成されていないので、問題ない。


fugaClass の fugafuga() の実行して、それから fugaClass に nil を代入してみる

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()
fugaClass = nil

// （出力）
// called hogehoge() on FugaClass
```

あれ、、、解放されていないみたい。。。

結局 weak var にする

```swift
class MogeClass {
    weak var delegate: HogeDelegate? // 結局 weak var にする
    
    init(delegate: HogeDelegate) {
        self.delegate = delegate
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate?.hogehoge()
    }
}
```

再Try

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()
fugaClass = nil

// （出力）
// called hogehoge() on FugaClass
// deinit: FugaClass
// deinit: MogeClass
```

うまくいきましたが、`lazy var` で self を渡すようにしても、やっぱり `weak var` をつけなればいけないのですね。。。

ただ、`private` をつければ、外からの変更は防げるので、それが気になる方はそうした方がいいかもしれませんね。

しかし、そもそも `lazy var` としている方が、変更のリスクが発生しますが、、、どっちがいいんでしょうね。

また、`private` をつけるのであれば、init での delegate の設定を忘れないように、`delegate` を使う際は強制アンラップしてもよいかもしれないですね。

```swift
class MogeClass {
    private weak var delegate: HogeDelegate? // private をつける
    
    init(delegate: HogeDelegate) {
        self.delegate = delegate
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate!.hogehoge() // 強制アンラップにする
    }
}
```

でも、init で設定しているはずなのに `delegate?` や `delegate!` とするのはなんかいけてませんよね。。。

`weak let` があれば、解決できそうですが、`weak let` を使おうとすると「`error: 'weak' must be a mutable variable, because it may change at runtime`」と怒られます。

どうやら `weak let` はないみたいですね。。。

そこで `unowned let` なんですよ！

```swift
class MogeClass {
    private unowned let delegate: HogeDelegate // unowned なら let を宣言できる
    
    init(delegate: HogeDelegate) {
        self.delegate = delegate
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate.hogehoge() // ? や ! も消せる
    }
}
```

再Try

```swift
var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()
fugaClass = nil

// （出力）
// called hogehoge() on FugaClass
// deinit: FugaClass
// deinit: MogeClass
```

うまくいきましたね。

`lazy var` で delegate となる self を init で渡すような場合は、`unowned let` を使っても良さそうですね。

全体像は以下になります。

```swift
protocol HogeDelegate: AnyObject {
    func hogehoge()
}

class MogeClass {
    private unowned let delegate: HogeDelegate
    
    init(delegate: HogeDelegate) {
        self.delegate = delegate
    }
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func mogemoge() {
        delegate.hogehoge()
    }
}

class FugaClass {
    lazy var mogeClass = MogeClass(delegate: self)
    
    deinit {
        print("deinit: \(type(of: self))")
    }
    
    func fugafuga() {
        mogeClass.mogemoge()
    }
}

extension FugaClass: HogeDelegate {
    func hogehoge() {
        print("called hogehoge() on FugaClass")
    }
}

var fugaClass: FugaClass? = FugaClass()
fugaClass?.fugafuga()
fugaClass = nil

// （出力）
// called hogehoge() on FugaClass
// deinit: FugaClass
// deinit: MogeClass
```

結論

delegate に対応した self を設定して、弱参照させるパターンは以下の2通りがある。

- delegate を代入する際は `weak var` で宣言した変数を使う
  - メリット：シンプルである
  - デメリット：delegate 変数の外部からの変更や、delegete 代入忘れの恐れがある
- `lazy var` で delegate に適応した self を init で渡す際は `unowned let` で宣言した変数を使った方が
  - メリット：`weak var` を使う場合にあったようなデメリットがなくなる
  - デメリット：`lazy var` を使う影響で、そちらの変数が変更される恐れや、init されるタイミングによって思わぬバグが発生する